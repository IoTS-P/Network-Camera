diff --git a/drivers/video/CMakeLists.txt b/drivers/video/CMakeLists.txt
index 68fd96d1b4c..2d354463168 100644
--- a/drivers/video/CMakeLists.txt
+++ b/drivers/video/CMakeLists.txt
@@ -9,3 +9,4 @@ zephyr_library_sources_ifdef(CONFIG_VIDEO_SW_GENERATOR	video_sw_generator.c)
 zephyr_library_sources_ifdef(CONFIG_VIDEO_MT9M114	mt9m114.c)
 zephyr_library_sources_ifdef(CONFIG_VIDEO_OV7725	ov7725.c)
 zephyr_library_sources_ifdef(CONFIG_VIDEO_OV2640	ov2640.c)
+zephyr_library_sources_ifdef(CONFIG_VIDEO_ARDUCAM_MEGA	arducam_mega.c)
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 488ad6c80cc..66b3af81a33 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -41,4 +41,7 @@ source "drivers/video/Kconfig.ov7725"
 
 source "drivers/video/Kconfig.ov2640"
 
+source "drivers/video/Kconfig.arducam_mega"
+
+
 endif # VIDEO
diff --git a/drivers/video/Kconfig.arducam_mega b/drivers/video/Kconfig.arducam_mega
new file mode 100644
index 00000000000..f3b2ee8f649
--- /dev/null
+++ b/drivers/video/Kconfig.arducam_mega
@@ -0,0 +1,12 @@
+# ARDUCAM_MEGA
+
+# Copyright (c) 2023 Arducam Technology Co., Ltd. <www.arducam.com>
+# SPDX-License-Identifier: Apache-2.0
+
+config VIDEO_ARDUCAM_MEGA
+	bool "Arducam Mega CMOS digital image sensor"
+	select SPI
+	depends on DT_HAS_ARDUCAM_MEGA_ENABLED
+	default y
+	help
+	  Enable driver for Arducam Mega CMOS digital image sensor device.
diff --git a/drivers/video/arducam_mega.c b/drivers/video/arducam_mega.c
new file mode 100644
index 00000000000..e790d88b037
--- /dev/null
+++ b/drivers/video/arducam_mega.c
@@ -0,0 +1,1048 @@
+/**
+ * Copyright (c) 2023 Arducam Technology Co., Ltd. <www.arducam.com>
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT arducam_mega
+
+#include <zephyr/drivers/video/arducam_mega.h>
+
+#include <zephyr/device.h>
+#include <zephyr/drivers/video.h>
+#include <zephyr/drivers/spi.h>
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(mega_camera);
+
+
+#define ARDUCHIP_FIFO   0x04 /* FIFO and I2C control */
+#define ARDUCHIP_FIFO_2 0x07 /* FIFO and I2C control */
+
+#define FIFO_CLEAR_ID_MASK 0x01
+#define FIFO_START_MASK    0x02
+
+#define ARDUCHIP_TRIG 0x44 /* Trigger source */
+#define VSYNC_MASK    0x01
+#define SHUTTER_MASK  0x02
+#define CAP_DONE_MASK 0x04
+
+#define FIFO_SIZE1 0x45 /* Camera write FIFO size[7:0] for burst to read */
+#define FIFO_SIZE2 0x46 /* Camera write FIFO size[15:8] */
+#define FIFO_SIZE3 0x47 /* Camera write FIFO size[18:16] */
+
+#define BURST_FIFO_READ  0x3C /* Burst FIFO read operation */
+#define SINGLE_FIFO_READ 0x3D /* Single FIFO read operation */
+
+/* DSP register bank FF=0x00*/
+#define CAM_REG_POWER_CONTROL                 0X02
+#define CAM_REG_SENSOR_RESET                  0X07
+#define CAM_REG_FORMAT                        0X20
+#define CAM_REG_CAPTURE_RESOLUTION            0X21
+#define CAM_REG_BRIGHTNESS_CONTROL            0X22
+#define CAM_REG_CONTRAST_CONTROL              0X23
+#define CAM_REG_SATURATION_CONTROL            0X24
+#define CAM_REG_EV_CONTROL                    0X25
+#define CAM_REG_WHITEBALANCE_CONTROL          0X26
+#define CAM_REG_COLOR_EFFECT_CONTROL          0X27
+#define CAM_REG_SHARPNESS_CONTROL             0X28
+#define CAM_REG_AUTO_FOCUS_CONTROL            0X29
+#define CAM_REG_IMAGE_QUALITY                 0x2A
+#define CAM_REG_EXPOSURE_GAIN_WHITEBAL_ENABLE 0X30
+#define CAM_REG_MANUAL_GAIN_BIT_9_8           0X31
+#define CAM_REG_MANUAL_GAIN_BIT_7_0           0X32
+#define CAM_REG_MANUAL_EXPOSURE_BIT_19_16     0X33
+#define CAM_REG_MANUAL_EXPOSURE_BIT_15_8      0X34
+#define CAM_REG_MANUAL_EXPOSURE_BIT_7_0       0X35
+#define CAM_REG_BURST_FIFO_READ_OPERATION     0X3C
+#define CAM_REG_SINGLE_FIFO_READ_OPERATION    0X3D
+#define CAM_REG_SENSOR_ID                     0x40
+#define CAM_REG_YEAR_SDK                      0x41
+#define CAM_REG_MONTH_SDK                     0x42
+#define CAM_REG_DAY_SDK                       0x43
+#define CAM_REG_SENSOR_STATE                  0x44
+#define CAM_REG_FPGA_VERSION_NUMBER           0x49
+#define CAM_REG_DEBUG_DEVICE_ADDRESS          0X0A
+#define CAM_REG_DEBUG_REGISTER_HIGH           0X0B
+#define CAM_REG_DEBUG_REGISTER_LOW            0X0C
+#define CAM_REG_DEBUG_REGISTER_VALUE          0X0D
+
+#define SENSOR_STATE_IDLE   (1 << 1)
+#define SENSOR_RESET_ENABLE (1 << 6)
+
+#define CTR_WHITEBALANCE 0X02
+#define CTR_EXPOSURE     0X01
+#define CTR_GAIN         0X00
+
+#define AC_STACK_SIZE 4096
+#define AC_PRIORITY 5
+
+K_THREAD_STACK_DEFINE(ac_stack_area, AC_STACK_SIZE);
+
+struct k_work_q ac_work_q;
+
+/**
+ * @struct mega_sdk_data
+ * @brief Basic information of the camera firmware
+ */
+struct mega_sdk_data {
+	uint8_t year;
+	uint8_t month;
+	uint8_t day;
+	uint8_t version;
+};
+
+struct arducam_mega_config {
+	struct spi_dt_spec bus;
+};
+
+struct arducam_mega_data {
+	const struct device *dev;
+	struct video_format fmt;
+	struct k_fifo fifo_in;
+	struct k_fifo fifo_out;
+	struct k_work buf_work;
+	struct k_timer stream_schedule_timer;
+	struct k_poll_signal *signal;
+	struct arducam_mega_info *info;
+	struct mega_sdk_data ver;
+	uint8_t fifo_first_read;
+	uint32_t fifo_length;
+	uint8_t stream_on;
+};
+
+static struct arducam_mega_info mega_infos[] = {{
+							.support_resolution = 7894,
+							.support_special_effects = 63,
+							.exposure_value_max = 30000,
+							.exposure_value_min = 1,
+							.gain_value_max = 1023,
+							.gain_value_min = 1,
+							.enable_focus = 1,
+							.enable_sharpness = 0,
+							.device_address = 0x78,
+						},
+						{
+							.support_resolution = 7638,
+							.support_special_effects = 319,
+							.exposure_value_max = 30000,
+							.exposure_value_min = 1,
+							.gain_value_max = 1023,
+							.gain_value_min = 1,
+							.enable_focus = 0,
+							.enable_sharpness = 1,
+							.device_address = 0x78,
+						}};
+
+#define ARDUCAM_MEGA_VIDEO_FORMAT_CAP(width, height, format)                                       \
+	{                                                                                          \
+		.pixelformat = (format), .width_min = (width), .width_max = (width),               \
+		.height_min = (height), .height_max = (height), .width_step = 0, .height_step = 0  \
+	}
+
+static struct video_format_cap fmts[] = {
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(96, 96, VIDEO_PIX_FMT_RGB565),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(128, 128, VIDEO_PIX_FMT_RGB565),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(320, 240, VIDEO_PIX_FMT_RGB565),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(320, 320, VIDEO_PIX_FMT_RGB565),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(640, 480, VIDEO_PIX_FMT_RGB565),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(1280, 720, VIDEO_PIX_FMT_RGB565),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(1600, 1200, VIDEO_PIX_FMT_RGB565),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(1920, 1080, VIDEO_PIX_FMT_RGB565),
+	{0},
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(96, 96, VIDEO_PIX_FMT_JPEG),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(128, 128, VIDEO_PIX_FMT_JPEG),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(320, 240, VIDEO_PIX_FMT_JPEG),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(320, 320, VIDEO_PIX_FMT_JPEG),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(640, 480, VIDEO_PIX_FMT_JPEG),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(1280, 720, VIDEO_PIX_FMT_JPEG),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(1600, 1200, VIDEO_PIX_FMT_JPEG),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(1920, 1080, VIDEO_PIX_FMT_JPEG),
+	{0},
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(96, 96, VIDEO_PIX_FMT_YUYV),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(128, 128, VIDEO_PIX_FMT_YUYV),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(320, 240, VIDEO_PIX_FMT_YUYV),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(320, 320, VIDEO_PIX_FMT_YUYV),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(640, 480, VIDEO_PIX_FMT_YUYV),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(1280, 720, VIDEO_PIX_FMT_YUYV),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(1600, 1200, VIDEO_PIX_FMT_YUYV),
+	ARDUCAM_MEGA_VIDEO_FORMAT_CAP(1920, 1080, VIDEO_PIX_FMT_YUYV),
+	{0},
+	{0},
+};
+
+#define SUPPORT_RESOLUTION_NUM 9
+
+static uint8_t support_resolution[SUPPORT_RESOLUTION_NUM] = {
+	MEGA_RESOLUTION_96X96,   MEGA_RESOLUTION_128X128, MEGA_RESOLUTION_QVGA,
+	MEGA_RESOLUTION_320X320, MEGA_RESOLUTION_VGA,     MEGA_RESOLUTION_HD,
+	MEGA_RESOLUTION_UXGA,    MEGA_RESOLUTION_FHD,     MEGA_RESOLUTION_NONE,
+};
+
+static int arducam_mega_write_reg(const struct spi_dt_spec *spec, uint8_t reg_addr, uint8_t value)
+{
+	uint8_t tries = 3;
+
+	reg_addr |= 0x80;
+
+	struct spi_buf tx_buf[2] = {
+		{.buf = &reg_addr, .len = 1},
+		{.buf = &value, .len = 1},
+	};
+
+	struct spi_buf_set tx_bufs = {.buffers = tx_buf, .count = 2};
+
+	while (tries--) {
+		if (!spi_write_dt(spec, &tx_bufs)) {
+			return 0;
+		}
+		/* If writing failed wait 5ms before next attempt */
+		k_msleep(5);
+	}
+	LOG_ERR("failed to write 0x%x to 0x%x", value, reg_addr);
+
+	return -1;
+}
+
+static int arducam_mega_read_reg(const struct spi_dt_spec *spec, uint8_t reg_addr)
+{
+	uint8_t tries = 3;
+	uint8_t value;
+	uint8_t ret;
+
+	reg_addr &= 0x7F;
+
+	struct spi_buf tx_buf[] = {
+		{.buf = &reg_addr, .len = 1},
+	};
+
+	struct spi_buf_set tx_bufs = {.buffers = tx_buf, .count = 1};
+
+	struct spi_buf rx_buf[] = {
+		{.buf = &value, .len = 1},
+		{.buf = &value, .len = 1},
+		{.buf = &value, .len = 1},
+	};
+
+	struct spi_buf_set rx_bufs = {.buffers = rx_buf, .count = 3};
+
+	while (tries--) {
+		ret = spi_transceive_dt(spec, &tx_bufs, &rx_bufs);
+		if (!ret) {
+			return value;
+		}
+
+		/* If reading failed wait 5ms before next attempt */
+		k_msleep(5);
+	}
+	LOG_ERR("failed to read 0x%x register", reg_addr);
+
+	return -1;
+}
+
+static int arducam_mega_read_block(const struct spi_dt_spec *spec, uint8_t *img_buff,
+				   uint32_t img_len, uint8_t first)
+{
+	uint8_t cmd_fifo_read[] = {BURST_FIFO_READ, 0x00};
+	uint8_t buf_len = first == 0 ? 1 : 2;
+
+	struct spi_buf tx_buf[] = {
+		{.buf = cmd_fifo_read, .len = buf_len},
+	};
+
+	struct spi_buf_set tx_bufs = {.buffers = tx_buf, .count = 1};
+
+	struct spi_buf rx_buf[2] = {
+		{.buf = cmd_fifo_read, .len = buf_len},
+		{.buf = img_buff, .len = img_len},
+	};
+	struct spi_buf_set rx_bufs = {.buffers = rx_buf, .count = 2};
+
+	return spi_transceive_dt(spec, &tx_bufs, &rx_bufs);
+}
+
+static int arducam_mega_await_bus_idle(const struct spi_dt_spec *spec, uint8_t tries)
+{
+	while ((arducam_mega_read_reg(spec, CAM_REG_SENSOR_STATE) & 0x03) != SENSOR_STATE_IDLE) {
+		if (tries-- == 0) {
+			return -1;
+		}
+		k_msleep(2);
+	}
+
+	return 0;
+}
+
+static int arducam_mega_set_brightness(const struct device *dev, enum MEGA_BRIGHTNESS_LEVEL level)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_BRIGHTNESS_CONTROL, level);
+
+	if (ret == -1) {
+		LOG_ERR("Failed to set brightness level %d", level);
+	}
+
+	return ret;
+}
+
+static int arducam_mega_set_saturation(const struct device *dev, enum MEGA_SATURATION_LEVEL level)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_SATURATION_CONTROL, level);
+
+	if (ret == -1) {
+		LOG_ERR("Failed to set saturation level %d", level);
+	}
+
+	return ret;
+}
+
+static int arducam_mega_set_contrast(const struct device *dev, enum MEGA_CONTRAST_LEVEL level)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_CONTRAST_CONTROL, level);
+
+	if (ret == -1) {
+		LOG_ERR("Failed to set contrast level %d", level);
+	}
+
+	return ret;
+}
+
+static int arducam_mega_set_EV(const struct device *dev, enum MEGA_EV_LEVEL level)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_EV_CONTROL, level);
+
+	if (ret == -1) {
+		LOG_ERR("Failed to set contrast level %d", level);
+	}
+
+	return ret;
+}
+
+static int arducam_mega_set_sharpness(const struct device *dev, enum MEGA_SHARPNESS_LEVEL level)
+{
+	int ret = 0;
+	struct arducam_mega_data *drv_data = dev->data;
+	struct arducam_mega_info *drv_info = drv_data->info;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	if (!drv_info->enable_sharpness) {
+		LOG_ERR("This device does not support set sharpness.");
+		return -1;
+	}
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_SHARPNESS_CONTROL, level);
+
+	if (ret == -1) {
+		LOG_ERR("Failed to set sharpness level %d", level);
+	}
+
+	return ret;
+}
+
+static int arducam_mega_set_special_effects(const struct device *dev, enum MEGA_COLOR_FX effect)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_COLOR_EFFECT_CONTROL, effect);
+
+	if (ret == -1) {
+		LOG_ERR("Failed to set special effects %d", effect);
+	}
+
+	return ret;
+}
+
+static int arducam_mega_set_output_format(const struct device *dev, int output_format)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	if (output_format == VIDEO_PIX_FMT_JPEG) {
+		/* Set output to JPEG compression */
+		ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_FORMAT, MEGA_PIXELFORMAT_JPG);
+	} else if (output_format == VIDEO_PIX_FMT_RGB565) {
+		/* Set output to RGB565 */
+		ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_FORMAT, MEGA_PIXELFORMAT_RGB565);
+	} else if (output_format == VIDEO_PIX_FMT_YUYV) {
+		/* Set output to YUV422 */
+		ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_FORMAT, MEGA_PIXELFORMAT_YUV);
+	} else {
+		LOG_ERR("Image format not supported");
+		return -ENOTSUP;
+	}
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 30);
+
+	return ret;
+}
+
+static int arducam_mega_set_JPEG_quality(const struct device *dev, enum MEGA_IMAGE_QUALITY qc)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+	struct arducam_mega_data *drv_data = dev->data;
+
+	LOG_DBG("%s: %d", __func__, qc);
+	if (drv_data->fmt.pixelformat == VIDEO_PIX_FMT_JPEG) {
+		ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+		/* Write QC register */
+		ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_IMAGE_QUALITY, qc);
+	} else {
+		LOG_ERR("Image format not support setting the quality");
+		return -ENOTSUP;
+	}
+
+	return ret;
+}
+
+static int arducam_mega_set_white_bal_enable(const struct device *dev, int enable)
+{
+	int ret = 0;
+	uint8_t reg = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	if (enable) {
+		reg |= 0x80;
+	}
+	reg |= CTR_WHITEBALANCE;
+	/* Update register to enable/disable automatic white balance*/
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_EXPOSURE_GAIN_WHITEBAL_ENABLE, reg);
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 10);
+
+	return ret;
+}
+
+static int arducam_mega_set_white_bal(const struct device *dev, enum MEGA_EV_LEVEL level)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_WHITEBALANCE_CONTROL, level);
+
+	if (ret == -1) {
+		LOG_ERR("Failed to set contrast level %d", level);
+	}
+
+	return ret;
+}
+
+static int arducam_mega_set_gain_enable(const struct device *dev, int enable)
+{
+	int ret = 0;
+	uint8_t reg = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	if (enable) {
+		reg |= 0x80;
+	}
+	reg |= CTR_GAIN;
+	/* Update register to enable/disable automatic gain*/
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_EXPOSURE_GAIN_WHITEBAL_ENABLE, reg);
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 10);
+
+	return ret;
+}
+
+static int arducam_mega_set_lowpower_enable(const struct device *dev, int enable)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+	const struct arducam_mega_data *drv_data = dev->data;
+	const struct arducam_mega_info *drv_info = drv_data->info;
+
+	if (drv_info->camera_id == ARDUCAM_SENSOR_5MP_2 ||
+	    drv_info->camera_id == ARDUCAM_SENSOR_3MP_2) {
+		enable = !enable;
+	}
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+	if (enable) {
+		ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_POWER_CONTROL, 0x07);
+	} else {
+		ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_POWER_CONTROL, 0x05);
+	}
+	return ret;
+}
+
+static int arducam_mega_set_gain(const struct device *dev, uint16_t value)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_MANUAL_GAIN_BIT_9_8, (value >> 8) & 0xff);
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 10);
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_MANUAL_GAIN_BIT_7_0, value & 0xff);
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 10);
+
+	return ret;
+}
+
+static int arducam_mega_set_exposure_enable(const struct device *dev, int enable)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	uint8_t reg = 0;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	if (enable) {
+		reg |= 0x80;
+	}
+	reg |= CTR_EXPOSURE;
+	/* Enable/disable automatic exposure control */
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_EXPOSURE_GAIN_WHITEBAL_ENABLE, reg);
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 10);
+	return ret;
+}
+
+static int arducam_mega_set_exposure(const struct device *dev, uint32_t value)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_MANUAL_EXPOSURE_BIT_19_16,
+				      (value >> 16) & 0xff);
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 10);
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_MANUAL_EXPOSURE_BIT_15_8,
+				      (value >> 8) & 0xff);
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 10);
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_MANUAL_EXPOSURE_BIT_7_0, value & 0xff);
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 10);
+	return ret;
+}
+
+static int arducam_mega_set_resolution(const struct device *dev, enum MEGA_RESOLUTION resolution)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 3);
+
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_CAPTURE_RESOLUTION, resolution);
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 10);
+
+	return ret;
+}
+
+static int arducam_mega_check_connection(const struct device *dev)
+{
+	int ret = 0;
+	uint8_t cam_id;
+	const struct arducam_mega_config *cfg = dev->config;
+	struct arducam_mega_data *drv_data = dev->data;
+
+	ret |= arducam_mega_await_bus_idle(&cfg->bus, 255);
+	cam_id = arducam_mega_read_reg(&cfg->bus, CAM_REG_SENSOR_ID);
+
+	if (!(cam_id & 0x87)) {
+		LOG_ERR("arducam mega not detected, 0x%x\n", cam_id);
+		return -ENODEV;
+	}
+
+	LOG_INF("detect camera id 0x%x, ret = %d\n", cam_id, ret);
+
+	switch (cam_id) {
+	case ARDUCAM_SENSOR_5MP_1: /* 5MP-1 */
+		fmts[8] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2592, 1944, VIDEO_PIX_FMT_RGB565);
+		fmts[17] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2592, 1944, VIDEO_PIX_FMT_JPEG);
+		fmts[26] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2592, 1944, VIDEO_PIX_FMT_YUYV);
+		support_resolution[8] = MEGA_RESOLUTION_WQXGA2;
+		drv_data->info = &mega_infos[0];
+		break;
+	case ARDUCAM_SENSOR_3MP_1: /* 3MP-1 */
+		fmts[8] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2048, 1536, VIDEO_PIX_FMT_RGB565);
+		fmts[17] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2048, 1536, VIDEO_PIX_FMT_JPEG);
+		fmts[26] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2048, 1536, VIDEO_PIX_FMT_YUYV);
+		support_resolution[8] = MEGA_RESOLUTION_QXGA;
+		drv_data->info = &mega_infos[1];
+		break;
+	case ARDUCAM_SENSOR_5MP_2: /* 5MP-2 */
+		fmts[8] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2592, 1936, VIDEO_PIX_FMT_RGB565);
+		fmts[17] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2592, 1936, VIDEO_PIX_FMT_JPEG);
+		fmts[26] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2592, 1936, VIDEO_PIX_FMT_YUYV);
+		support_resolution[8] = MEGA_RESOLUTION_WQXGA2;
+		break;
+		drv_data->info = &mega_infos[0];
+		break;
+	case ARDUCAM_SENSOR_3MP_2: /* 3MP-2 */
+		fmts[8] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2048, 1536, VIDEO_PIX_FMT_RGB565);
+		fmts[17] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2048, 1536, VIDEO_PIX_FMT_JPEG);
+		fmts[26] = (struct video_format_cap)ARDUCAM_MEGA_VIDEO_FORMAT_CAP(
+			2048, 1536, VIDEO_PIX_FMT_YUYV);
+		support_resolution[8] = MEGA_RESOLUTION_QXGA;
+		break;
+		drv_data->info = &mega_infos[1];
+		break;
+	default:
+		return -ENODEV;
+	}
+	drv_data->info->camera_id = cam_id;
+
+	return ret;
+}
+
+static int arducam_mega_set_fmt(const struct device *dev, enum video_endpoint_id ep,
+				struct video_format *fmt)
+{
+	struct arducam_mega_data *drv_data = dev->data;
+	uint16_t width, height;
+	int ret = 0;
+	int i = 0;
+
+	/* We only support RGB565, JPEG, and YUYV pixel formats */
+	if (fmt->pixelformat != VIDEO_PIX_FMT_RGB565 && fmt->pixelformat != VIDEO_PIX_FMT_JPEG &&
+	    fmt->pixelformat != VIDEO_PIX_FMT_YUYV) {
+		LOG_ERR("Arducam Mega camera only supports RGB565, JPG, and YUYV pixel formats!");
+		return -ENOTSUP;
+	}
+
+	width = fmt->width;
+	height = fmt->height;
+
+	if (!memcmp(&drv_data->fmt, fmt, sizeof(drv_data->fmt))) {
+		/* nothing to do */
+		return 0;
+	}
+
+	/* Check if camera is capable of handling given format */
+	while (fmts[i].pixelformat) {
+		if (fmts[i].width_min == width && fmts[i].height_min == height &&
+		    fmts[i].pixelformat == fmt->pixelformat) {
+			/* Set output format */
+			ret |= arducam_mega_set_output_format(dev, fmt->pixelformat);
+			/* Set window size */
+			ret |= arducam_mega_set_resolution(
+				dev, support_resolution[i % SUPPORT_RESOLUTION_NUM]);
+			if (!ret) {
+				drv_data->fmt = *fmt;
+				drv_data->fmt.pitch = drv_data->fmt.width * 2;
+			}
+			return ret;
+		}
+		i++;
+	}
+	/* Camera is not capable of handling given format */
+	LOG_ERR("Image resolution not supported\n");
+	return -ENOTSUP;
+}
+
+static int arducam_mega_get_fmt(const struct device *dev, enum video_endpoint_id ep,
+				struct video_format *fmt)
+{
+	struct arducam_mega_data *drv_data = dev->data;
+
+	*fmt = drv_data->fmt;
+
+	return 0;
+}
+
+static void on_stream_schedule_timer_func(struct k_timer *timer)
+{
+	struct arducam_mega_data *drv_data = timer->user_data;
+
+	k_work_submit_to_queue(&ac_work_q, &drv_data->buf_work);
+}
+
+static int arducam_mega_stream_start(const struct device *dev)
+{
+	struct arducam_mega_data *drv_data = dev->data;
+
+	if (drv_data->stream_on) {
+		return 0;
+	}
+
+	drv_data->stream_on = 1;
+	drv_data->fifo_length = 0;
+
+	k_timer_start(&drv_data->stream_schedule_timer, K_MSEC(30), K_MSEC(30));
+
+	return 0;
+}
+
+static int arducam_mega_stream_stop(const struct device *dev)
+{
+	struct arducam_mega_data *drv_data = dev->data;
+
+	drv_data->stream_on = 0;
+
+	k_timer_stop(&drv_data->stream_schedule_timer);
+
+	return 0;
+}
+
+static int arducam_mega_flush(const struct device *dev, enum video_endpoint_id ep, bool cancel)
+{
+	struct arducam_mega_data *drv_data = dev->data;
+	struct video_buffer *vbuf;
+
+	/* Clear fifo cache */
+	while (!k_fifo_is_empty(&drv_data->fifo_out)) {
+		vbuf = k_fifo_get(&drv_data->fifo_out, K_USEC(10));
+		if (vbuf != NULL) {
+			k_fifo_put(&drv_data->fifo_in, vbuf);
+		}
+	}
+	return 0;
+}
+
+static int arducam_mega_soft_reset(const struct device *dev)
+{
+	int ret = 0;
+	const struct arducam_mega_config *cfg = dev->config;
+	struct arducam_mega_data *drv_data = dev->data;
+
+	if (drv_data->stream_on) {
+		arducam_mega_stream_stop(dev);
+	}
+	/* Initiate system reset */
+	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_SENSOR_RESET, SENSOR_RESET_ENABLE);
+	k_msleep(1000);
+
+	return ret;
+}
+
+static int arducam_mega_capture(const struct device *dev, uint32_t *length)
+{
+	const struct arducam_mega_config *cfg = dev->config;
+	struct arducam_mega_data *drv_data = dev->data;
+	uint8_t tries = 200;
+
+	arducam_mega_write_reg(&cfg->bus, ARDUCHIP_FIFO, FIFO_CLEAR_ID_MASK);
+	arducam_mega_write_reg(&cfg->bus, ARDUCHIP_FIFO, FIFO_START_MASK);
+
+	do {
+		if (tries-- == 0) {
+			LOG_ERR("Capture timeout!");
+			return -1;
+		}
+		k_msleep(2);
+	} while (!(arducam_mega_read_reg(&cfg->bus, ARDUCHIP_TRIG) & CAP_DONE_MASK));
+
+	drv_data->fifo_length = arducam_mega_read_reg(&cfg->bus, FIFO_SIZE1);
+	drv_data->fifo_length |= (arducam_mega_read_reg(&cfg->bus, FIFO_SIZE2) << 8);
+	drv_data->fifo_length |= (arducam_mega_read_reg(&cfg->bus, FIFO_SIZE3) << 16);
+
+	drv_data->fifo_first_read = 1;
+	*length = drv_data->fifo_length;
+	return 0;
+}
+
+static int arducam_mega_fifo_read(const struct device *dev, struct video_buffer *buf)
+{
+	int ret;
+	int32_t rlen;
+	const struct arducam_mega_config *cfg = dev->config;
+	struct arducam_mega_data *drv_data = dev->data;
+
+	rlen = buf->size > drv_data->fifo_length ? drv_data->fifo_length : buf->size;
+
+	LOG_DBG("read fifo :%u. - fifo_length %u", buf->size, drv_data->fifo_length);
+
+	ret = arducam_mega_read_block(&cfg->bus, buf->buffer, rlen, drv_data->fifo_first_read);
+
+	if (ret == 0) {
+		drv_data->fifo_length -= rlen;
+		buf->bytesused = rlen;
+		if (drv_data->fifo_first_read) {
+			drv_data->fifo_first_read = 0;
+		}
+	}
+
+	return ret;
+}
+
+static void __buffer_work(struct k_work *work)
+{
+	struct k_work *dwork = work;
+	struct arducam_mega_data *drv_data =
+		CONTAINER_OF(dwork, struct arducam_mega_data, buf_work);
+	static uint32_t f_timestamp, f_length;
+	struct video_buffer *vbuf;
+
+	vbuf = k_fifo_get(&drv_data->fifo_in, K_FOREVER);
+
+
+	if (vbuf == NULL) {
+		return;
+	}
+
+	if (drv_data->fifo_length == 0) {
+		arducam_mega_capture(drv_data->dev, &f_length);
+		f_timestamp = k_uptime_get_32();
+	}
+
+	arducam_mega_fifo_read(drv_data->dev, vbuf);
+
+	if (drv_data->fifo_length == 0) {
+		vbuf->flags = VIDEO_BUF_EOF;
+	} else {
+		vbuf->flags = VIDEO_BUF_FRAG;
+		k_work_submit_to_queue(&ac_work_q, &drv_data->buf_work);
+	}
+
+	vbuf->timestamp = f_timestamp;
+	vbuf->bytesframe = f_length;
+	k_fifo_put(&drv_data->fifo_out, vbuf);
+
+	k_yield();
+}
+
+static int arducam_mega_enqueue(const struct device *dev, enum video_endpoint_id ep,
+				struct video_buffer *vbuf)
+{
+	struct arducam_mega_data *data = dev->data;
+
+	if (ep != VIDEO_EP_OUT) {
+		return -EINVAL;
+	}
+	k_fifo_put(&data->fifo_in, vbuf);
+
+	LOG_DBG("enqueue buffer %p", vbuf->buffer);
+
+	return 0;
+}
+
+static int arducam_mega_dequeue(const struct device *dev, enum video_endpoint_id ep,
+				struct video_buffer **vbuf, k_timeout_t timeout)
+{
+	struct arducam_mega_data *data = dev->data;
+
+	if (ep != VIDEO_EP_OUT) {
+		return -EINVAL;
+	}
+
+	*vbuf = k_fifo_get(&data->fifo_out, timeout);
+
+	LOG_DBG("dequeue buffer %p", (*vbuf)->buffer);
+
+	if (*vbuf == NULL) {
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+static int arducam_mega_get_caps(const struct device *dev, enum video_endpoint_id ep,
+				 struct video_caps *caps)
+{
+	caps->format_caps = fmts;
+	return 0;
+}
+
+static int arducam_mega_set_ctrl(const struct device *dev, unsigned int cid, void *value)
+{
+	int ret = 0;
+
+	switch (cid) {
+	case VIDEO_CID_CAMERA_EXPOSURE_AUTO:
+		ret |= arducam_mega_set_exposure_enable(dev, *(uint8_t *)value);
+		break;
+	case VIDEO_CID_CAMERA_EXPOSURE:
+		ret |= arducam_mega_set_exposure(dev, *(uint32_t *)value);
+		break;
+	case VIDEO_CID_CAMERA_GAIN_AUTO:
+		ret |= arducam_mega_set_gain_enable(dev, *(uint8_t *)value);
+		break;
+	case VIDEO_CID_CAMERA_GAIN:
+		ret |= arducam_mega_set_gain(dev, *(uint16_t *)value);
+		break;
+	case VIDEO_CID_CAMERA_BRIGHTNESS:
+		ret |= arducam_mega_set_brightness(dev, *(enum MEGA_BRIGHTNESS_LEVEL *)value);
+		break;
+	case VIDEO_CID_CAMERA_SATURATION:
+		ret |= arducam_mega_set_saturation(dev, *(enum MEGA_SATURATION_LEVEL *)value);
+		break;
+	case VIDEO_CID_CAMERA_WHITE_BAL_AUTO:
+		ret |= arducam_mega_set_white_bal_enable(dev, *(uint8_t *)value);
+		break;
+	case VIDEO_CID_CAMERA_WHITE_BAL:
+		ret |= arducam_mega_set_white_bal(dev, *(enum MEGA_WHITE_BALANCE *)value);
+		break;
+	case VIDEO_CID_CAMERA_CONTRAST:
+		ret |= arducam_mega_set_contrast(dev, *(enum MEGA_CONTRAST_LEVEL *)value);
+		break;
+	case VIDEO_CID_JPEG_COMPRESSION_QUALITY:
+		ret |= arducam_mega_set_JPEG_quality(dev, *(enum MEGA_IMAGE_QUALITY *)value);
+		break;
+	case VIDEO_CID_ARDUCAM_EV:
+		ret |= arducam_mega_set_EV(dev, *(enum MEGA_EV_LEVEL *)value);
+		break;
+	case VIDEO_CID_ARDUCAM_SHARPNESS:
+		ret |= arducam_mega_set_sharpness(dev, *(enum MEGA_SHARPNESS_LEVEL *)value);
+		break;
+	case VIDEO_CID_ARDUCAM_COLOR_FX:
+		ret |= arducam_mega_set_special_effects(dev, *(enum MEGA_COLOR_FX *)value);
+		break;
+	case VIDEO_CID_ARDUCAM_RESET:
+		ret |= arducam_mega_soft_reset(dev);
+		ret |= arducam_mega_check_connection(dev);
+		break;
+	case VIDEO_CID_ARDUCAM_LOWPOWER:
+		ret |= arducam_mega_set_lowpower_enable(dev, *(uint8_t *)value);
+		break;
+	default:
+		return -ENOTSUP;
+	}
+
+	return ret;
+}
+
+int arducam_mega_get_info(const struct device *dev, struct arducam_mega_info *info)
+{
+	struct arducam_mega_data *drv_data = dev->data;
+
+	*info = (*drv_data->info);
+
+	return 0;
+}
+
+static int arducam_mega_get_ctrl(const struct device *dev, unsigned int cid, void *value)
+{
+	int ret = 0;
+
+	switch (cid) {
+	case VIDEO_CID_ARDUCAM_INFO:
+		ret |= arducam_mega_get_info(dev, (struct arducam_mega_info *)value);
+		break;
+	default:
+		return -ENOTSUP;
+	}
+
+	return ret;
+}
+
+static const struct video_driver_api arducam_mega_driver_api = {
+	.set_format = arducam_mega_set_fmt,
+	.get_format = arducam_mega_get_fmt,
+	.stream_start = arducam_mega_stream_start,
+	.stream_stop = arducam_mega_stream_stop,
+	.get_caps = arducam_mega_get_caps,
+	.flush = arducam_mega_flush,
+	.set_ctrl = arducam_mega_set_ctrl,
+	.get_ctrl = arducam_mega_get_ctrl,
+	.enqueue = arducam_mega_enqueue,
+	.dequeue = arducam_mega_dequeue,
+};
+
+static int arducam_mega_init(const struct device *dev)
+{
+	const struct arducam_mega_config *cfg = dev->config;
+	struct arducam_mega_data *drv_data = dev->data;
+
+	struct video_format fmt;
+	int ret = 0;
+
+	if (!spi_is_ready_dt(&cfg->bus)) {
+		LOG_ERR("%s: device is not ready", cfg->bus.bus->name);
+		return -ENODEV;
+	}
+
+	drv_data->dev = dev;
+	k_fifo_init(&drv_data->fifo_in);
+	k_fifo_init(&drv_data->fifo_out);
+	k_work_queue_init(&ac_work_q);
+	k_work_queue_start(&ac_work_q, ac_stack_area, K_THREAD_STACK_SIZEOF(ac_stack_area),
+		AC_PRIORITY, NULL);
+
+	k_timer_init(&drv_data->stream_schedule_timer, on_stream_schedule_timer_func, NULL);
+	drv_data->stream_schedule_timer.user_data = (void *)drv_data;
+
+	k_work_init(&drv_data->buf_work, __buffer_work);
+
+	arducam_mega_soft_reset(dev);
+	ret = arducam_mega_check_connection(dev);
+
+	if (ret) {
+		LOG_ERR("arducam mega camera not connection.\n");
+		return ret;
+	}
+
+	drv_data->ver.year = arducam_mega_read_reg(&cfg->bus, CAM_REG_YEAR_SDK) & 0x3F;
+	drv_data->ver.month = arducam_mega_read_reg(&cfg->bus, CAM_REG_MONTH_SDK) & 0x0F;
+	drv_data->ver.day = arducam_mega_read_reg(&cfg->bus, CAM_REG_DAY_SDK) & 0x1F;
+	drv_data->ver.version =
+		arducam_mega_read_reg(&cfg->bus, CAM_REG_FPGA_VERSION_NUMBER) & 0xfF;
+
+	LOG_INF("arducam mega ver: %d-%d-%d \t %x", drv_data->ver.year, drv_data->ver.month,
+		drv_data->ver.day, drv_data->ver.version);
+
+	/* set default/init format 96x96 RGB565 */
+	fmt.pixelformat = VIDEO_PIX_FMT_RGB565;
+	fmt.width = 96;
+	fmt.height = 96;
+	fmt.pitch = 96 * 2;
+	ret = arducam_mega_set_fmt(dev, VIDEO_EP_OUT, &fmt);
+	if (ret) {
+		LOG_ERR("Unable to configure default format");
+		return -EIO;
+	}
+
+	return ret;
+}
+
+#define ARDUCAM_MEGA_INIT(inst)                                                                    \
+	static const struct arducam_mega_config arducam_mega_cfg_##inst = {                        \
+		.bus = SPI_DT_SPEC_INST_GET(inst,                                                  \
+					    SPI_OP_MODE_MASTER | SPI_WORD_SET(8) |                 \
+						    SPI_CS_ACTIVE_HIGH | SPI_LINES_SINGLE |        \
+						    SPI_LOCK_ON,                                   \
+					    0),                                                    \
+	};                                                                                         \
+                                                                                                   \
+	static struct arducam_mega_data arducam_mega_data_##inst;                                  \
+                                                                                                   \
+	DEVICE_DT_INST_DEFINE(inst, &arducam_mega_init, NULL, &arducam_mega_data_##inst,           \
+			      &arducam_mega_cfg_##inst, POST_KERNEL, CONFIG_VIDEO_INIT_PRIORITY,   \
+			      &arducam_mega_driver_api);
+
+DT_INST_FOREACH_STATUS_OKAY(ARDUCAM_MEGA_INIT)
diff --git a/dts/bindings/vendor-prefixes.txt b/dts/bindings/vendor-prefixes.txt
index 29a7b78aa70..a3899aeedcc 100644
--- a/dts/bindings/vendor-prefixes.txt
+++ b/dts/bindings/vendor-prefixes.txt
@@ -62,6 +62,7 @@ archermind	ArcherMind Technology (Nanjing) Co., Ltd.
 arc	Synopsys, Inc. (formerly ARC International PLC)
 arctic	Arctic Sand
 arcx	arcx Inc. / Archronix Inc.
+arducam	Arducam Technology Co., Limited
 arduino	Arduino
 aries	Aries Embedded GmbH
 arm	ARM Ltd.
diff --git a/dts/bindings/video/arducam,mega.yaml b/dts/bindings/video/arducam,mega.yaml
new file mode 100644
index 00000000000..02c72b21689
--- /dev/null
+++ b/dts/bindings/video/arducam,mega.yaml
@@ -0,0 +1,10 @@
+# ARDUCAM_MEGA
+
+# Copyright (c) 2023 Arducam Technology Co., Ltd. <www.arducam.com>
+# SPDX-License-Identifier: Apache-2.0
+
+description: Arducam Mega CMOS video sensor
+
+compatible: "arducam,mega"
+
+include: spi-device.yaml
diff --git a/include/zephyr/drivers/video-controls.h b/include/zephyr/drivers/video-controls.h
index 7912ab0d91c..1ed9f878495 100644
--- a/include/zephyr/drivers/video-controls.h
+++ b/include/zephyr/drivers/video-controls.h
@@ -58,15 +58,31 @@ extern "C" {
  * @name Camera class control IDs
  * @{
  */
-#define VIDEO_CID_CAMERA_EXPOSURE	(VIDEO_CTRL_CLASS_CAMERA + 0)
-#define VIDEO_CID_CAMERA_GAIN		(VIDEO_CTRL_CLASS_CAMERA + 1)
-#define VIDEO_CID_CAMERA_ZOOM		(VIDEO_CTRL_CLASS_CAMERA + 2)
-#define VIDEO_CID_CAMERA_BRIGHTNESS	(VIDEO_CTRL_CLASS_CAMERA + 3)
-#define VIDEO_CID_CAMERA_SATURATION	(VIDEO_CTRL_CLASS_CAMERA + 4)
-#define VIDEO_CID_CAMERA_WHITE_BAL	(VIDEO_CTRL_CLASS_CAMERA + 5)
-#define VIDEO_CID_CAMERA_CONTRAST	(VIDEO_CTRL_CLASS_CAMERA + 6)
-#define VIDEO_CID_CAMERA_COLORBAR	(VIDEO_CTRL_CLASS_CAMERA + 7)
-#define VIDEO_CID_CAMERA_QUALITY	(VIDEO_CTRL_CLASS_CAMERA + 8)
+#define VIDEO_CID_CAMERA_EXPOSURE_AUTO (VIDEO_CTRL_CLASS_CAMERA + 0)
+#define VIDEO_CID_CAMERA_EXPOSURE      (VIDEO_CTRL_CLASS_CAMERA + 1)
+
+#define VIDEO_CID_CAMERA_GAIN_AUTO (VIDEO_CTRL_CLASS_CAMERA + 2)
+#define VIDEO_CID_CAMERA_GAIN      (VIDEO_CTRL_CLASS_CAMERA + 3)
+
+#define VIDEO_CID_CAMERA_ZOOM		(VIDEO_CTRL_CLASS_CAMERA + 4)
+#define VIDEO_CID_CAMERA_BRIGHTNESS	(VIDEO_CTRL_CLASS_CAMERA + 5)
+#define VIDEO_CID_CAMERA_SATURATION	(VIDEO_CTRL_CLASS_CAMERA + 6)
+
+#define VIDEO_CID_CAMERA_WHITE_BAL_AUTO (VIDEO_CTRL_CLASS_CAMERA + 7)
+#define VIDEO_CID_CAMERA_WHITE_BAL      (VIDEO_CTRL_CLASS_CAMERA + 8)
+
+#define VIDEO_CID_CAMERA_CONTRAST	(VIDEO_CTRL_CLASS_CAMERA + 9)
+#define VIDEO_CID_CAMERA_COLORBAR	(VIDEO_CTRL_CLASS_CAMERA + 10)
+#define VIDEO_CID_CAMERA_QUALITY	(VIDEO_CTRL_CLASS_CAMERA + 11)
+/**
+ * @}
+ */
+
+/**
+ * @name JPEG-compression class control IDs
+ * @{
+ */
+#define VIDEO_CID_JPEG_COMPRESSION_QUALITY (VIDEO_CTRL_CLASS_JPEG + 0)
 /**
  * @}
  */
diff --git a/include/zephyr/drivers/video.h b/include/zephyr/drivers/video.h
index 9a29d9f055e..b629a5e8e85 100644
--- a/include/zephyr/drivers/video.h
+++ b/include/zephyr/drivers/video.h
@@ -94,6 +94,16 @@ struct video_caps {
 	uint8_t min_vbuf_count;
 };
 
+/**
+ * @brief video_frame_fragmented_status enum
+ *
+ * Indicates the receiving status of fragmented frames.
+ */
+enum video_frame_fragmented_status {
+	VIDEO_BUF_FRAG,
+	VIDEO_BUF_EOF,
+};
+
 /**
  * @struct video_buffer
  * @brief Video buffer structure
@@ -114,6 +124,10 @@ struct video_buffer {
 	 * endpoints.
 	 */
 	uint32_t timestamp;
+	/** frame length for fragmented frames. */
+	uint32_t bytesframe;
+	/** receiving status for fragmented frames. */
+	uint32_t flags;
 };
 
 /**
diff --git a/include/zephyr/drivers/video/arducam_mega.h b/include/zephyr/drivers/video/arducam_mega.h
new file mode 100644
index 00000000000..e32d6b976e1
--- /dev/null
+++ b/include/zephyr/drivers/video/arducam_mega.h
@@ -0,0 +1,196 @@
+/**
+ * Copyright (c) 2023 Arducam Technology Co., Ltd. <www.arducam.com>
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef ZEPHYR_INCLUDE_DRIVERS_CAMERA_ARDUCAM_MEGA_H_
+#define ZEPHYR_INCLUDE_DRIVERS_CAMERA_ARDUCAM_MEGA_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define VIDEO_CID_ARDUCAM_EV        (VIDEO_CTRL_CLASS_VENDOR + 1)
+#define VIDEO_CID_ARDUCAM_INFO      (VIDEO_CTRL_CLASS_VENDOR + 2)
+#define VIDEO_CID_ARDUCAM_SHARPNESS (VIDEO_CTRL_CLASS_VENDOR + 3)
+#define VIDEO_CID_ARDUCAM_COLOR_FX  (VIDEO_CTRL_CLASS_VENDOR + 4)
+#define VIDEO_CID_ARDUCAM_RESET     (VIDEO_CTRL_CLASS_VENDOR + 5)
+#define VIDEO_CID_ARDUCAM_LOWPOWER  (VIDEO_CTRL_CLASS_VENDOR + 6)
+
+/**
+ * @enum MEGA_CONTRAST_LEVEL
+ * @brief Configure camera contrast level
+ */
+enum MEGA_CONTRAST_LEVEL {
+	MEGA_CONTRAST_LEVEL_NEGATIVE_3 = 6, /**<Level -3 */
+	MEGA_CONTRAST_LEVEL_NEGATIVE_2 = 4, /**<Level -2 */
+	MEGA_CONTRAST_LEVEL_NEGATIVE_1 = 2, /**<Level -1 */
+	MEGA_CONTRAST_LEVEL_DEFAULT = 0,    /**<Level Default*/
+	MEGA_CONTRAST_LEVEL_1 = 1,          /**<Level +1 */
+	MEGA_CONTRAST_LEVEL_2 = 3,          /**<Level +2 */
+	MEGA_CONTRAST_LEVEL_3 = 5,          /**<Level +3 */
+};
+
+/**
+ * @enum MEGA_EV_LEVEL
+ * @brief Configure camera EV level
+ */
+enum MEGA_EV_LEVEL {
+	MEGA_EV_LEVEL_NEGATIVE_3 = 6, /**<Level -3 */
+	MEGA_EV_LEVEL_NEGATIVE_2 = 4, /**<Level -2 */
+	MEGA_EV_LEVEL_NEGATIVE_1 = 2, /**<Level -1 */
+	MEGA_EV_LEVEL_DEFAULT = 0,    /**<Level Default*/
+	MEGA_EV_LEVEL_1 = 1,          /**<Level +1 */
+	MEGA_EV_LEVEL_2 = 3,          /**<Level +2 */
+	MEGA_EV_LEVEL_3 = 5,          /**<Level +3 */
+};
+
+/**
+ * @enum MEGA_SATURATION_LEVEL
+ * @brief Configure camera saturation  level
+ */
+enum MEGA_SATURATION_LEVEL {
+	MEGA_SATURATION_LEVEL_NEGATIVE_3 = 6, /**<Level -3 */
+	MEGA_SATURATION_LEVEL_NEGATIVE_2 = 4, /**<Level -2 */
+	MEGA_SATURATION_LEVEL_NEGATIVE_1 = 2, /**<Level -1 */
+	MEGA_SATURATION_LEVEL_DEFAULT = 0,    /**<Level Default*/
+	MEGA_SATURATION_LEVEL_1 = 1,          /**<Level +1 */
+	MEGA_SATURATION_LEVEL_2 = 3,          /**<Level +2 */
+	MEGA_SATURATION_LEVEL_3 = 5,          /**<Level +3 */
+};
+
+/**
+ * @enum MEGA_BRIGHTNESS_LEVEL
+ * @brief Configure camera brightness level
+ */
+enum MEGA_BRIGHTNESS_LEVEL {
+	MEGA_BRIGHTNESS_LEVEL_NEGATIVE_4 = 8, /**<Level -4 */
+	MEGA_BRIGHTNESS_LEVEL_NEGATIVE_3 = 6, /**<Level -3 */
+	MEGA_BRIGHTNESS_LEVEL_NEGATIVE_2 = 4, /**<Level -2 */
+	MEGA_BRIGHTNESS_LEVEL_NEGATIVE_1 = 2, /**<Level -1 */
+	MEGA_BRIGHTNESS_LEVEL_DEFAULT = 0,    /**<Level Default*/
+	MEGA_BRIGHTNESS_LEVEL_1 = 1,          /**<Level +1 */
+	MEGA_BRIGHTNESS_LEVEL_2 = 3,          /**<Level +2 */
+	MEGA_BRIGHTNESS_LEVEL_3 = 5,          /**<Level +3 */
+	MEGA_BRIGHTNESS_LEVEL_4 = 7,          /**<Level +4 */
+};
+
+/**
+ * @enum MEGA_SHARPNESS_LEVEL
+ * @brief Configure camera Sharpness level
+ */
+enum MEGA_SHARPNESS_LEVEL {
+	MEGA_SHARPNESS_LEVEL_AUTO = 0, /**<Sharpness Auto */
+	MEGA_SHARPNESS_LEVEL_1,        /**<Sharpness Level 1 */
+	MEGA_SHARPNESS_LEVEL_2,        /**<Sharpness Level 2 */
+	MEGA_SHARPNESS_LEVEL_3,        /**<Sharpness Level 3 */
+	MEGA_SHARPNESS_LEVEL_4,        /**<Sharpness Level 4 */
+	MEGA_SHARPNESS_LEVEL_5,        /**<Sharpness Level 5 */
+	MEGA_SHARPNESS_LEVEL_6,        /**<Sharpness Level 6 */
+	MEGA_SHARPNESS_LEVEL_7,        /**<Sharpness Level 7 */
+	MEGA_SHARPNESS_LEVEL_8,        /**<Sharpness Level 8 */
+};
+
+/**
+ * @enum MEGA_COLOR_FX
+ * @brief Configure special effects
+ */
+enum MEGA_COLOR_FX {
+	MEGA_COLOR_FX_NONE = 0,      /**< no effect   */
+	MEGA_COLOR_FX_BLUEISH,       /**< cool light   */
+	MEGA_COLOR_FX_REDISH,        /**< warm   */
+	MEGA_COLOR_FX_BW,            /**< Black/white   */
+	MEGA_COLOR_FX_SEPIA,         /**<Sepia   */
+	MEGA_COLOR_FX_NEGATIVE,      /**<positive/negative inversion  */
+	MEGA_COLOR_FX_GRASS_GREEN,   /**<Grass green */
+	MEGA_COLOR_FX_OVER_EXPOSURE, /**<Over exposure*/
+	MEGA_COLOR_FX_SOLARIZE,      /**< Solarize   */
+};
+
+/**
+ * @enum MEGA_WHITE_BALANCE
+ * @brief Configure white balance mode
+ */
+enum MEGA_WHITE_BALANCE {
+	MEGA_WHITE_BALANCE_MODE_DEFAULT = 0, /**< Auto */
+	MEGA_WHITE_BALANCE_MODE_SUNNY,       /**< Sunny */
+	MEGA_WHITE_BALANCE_MODE_OFFICE,      /**< Office */
+	MEGA_WHITE_BALANCE_MODE_CLOUDY,      /**< Cloudy*/
+	MEGA_WHITE_BALANCE_MODE_HOME,        /**< Home */
+};
+
+/**
+ * @enum MEGA_IMAGE_QUALITY
+ * @brief Configure JPEG image quality
+ */
+enum MEGA_IMAGE_QUALITY {
+	HIGH_QUALITY = 0,
+	DEFAULT_QUALITY = 1,
+	LOW_QUALITY = 2,
+};
+
+enum {
+	ARDUCAM_SENSOR_5MP_1 = 0x81,
+	ARDUCAM_SENSOR_3MP_1 = 0x82,
+	ARDUCAM_SENSOR_5MP_2 = 0x83, /* 2592x1936 */
+	ARDUCAM_SENSOR_3MP_2 = 0x84,
+};
+
+/**
+ * @enum MEGA_PIXELFORMAT
+ * @brief Configure camera pixel format
+ */
+enum MEGA_PIXELFORMAT {
+	MEGA_PIXELFORMAT_JPG = 0X01,
+	MEGA_PIXELFORMAT_RGB565 = 0X02,
+	MEGA_PIXELFORMAT_YUV = 0X03,
+};
+
+/**
+ * @enum MEGA_RESOLUTION
+ * @brief Configure camera resolution
+ */
+enum MEGA_RESOLUTION {
+	MEGA_RESOLUTION_QQVGA = 0x00,   /**<160x120 */
+	MEGA_RESOLUTION_QVGA = 0x01,    /**<320x240*/
+	MEGA_RESOLUTION_VGA = 0x02,     /**<640x480*/
+	MEGA_RESOLUTION_SVGA = 0x03,    /**<800x600*/
+	MEGA_RESOLUTION_HD = 0x04,      /**<1280x720*/
+	MEGA_RESOLUTION_SXGAM = 0x05,   /**<1280x960*/
+	MEGA_RESOLUTION_UXGA = 0x06,    /**<1600x1200*/
+	MEGA_RESOLUTION_FHD = 0x07,     /**<1920x1080*/
+	MEGA_RESOLUTION_QXGA = 0x08,    /**<2048x1536*/
+	MEGA_RESOLUTION_WQXGA2 = 0x09,  /**<2592x1944*/
+	MEGA_RESOLUTION_96X96 = 0x0a,   /**<96x96*/
+	MEGA_RESOLUTION_128X128 = 0x0b, /**<128x128*/
+	MEGA_RESOLUTION_320X320 = 0x0c, /**<320x320*/
+	MEGA_RESOLUTION_12 = 0x0d,      /**<Reserve*/
+	MEGA_RESOLUTION_13 = 0x0e,      /**<Reserve*/
+	MEGA_RESOLUTION_14 = 0x0f,      /**<Reserve*/
+	MEGA_RESOLUTION_15 = 0x10,      /**<Reserve*/
+	MEGA_RESOLUTION_NONE,
+};
+
+/**
+ * @struct arducam_mega_info
+ * @brief Some information about mega camera
+ */
+struct arducam_mega_info {
+	int support_resolution;
+	int support_special_effects;
+	unsigned long exposure_value_max;
+	unsigned int exposure_value_min;
+	unsigned int gain_value_max;
+	unsigned int gain_value_min;
+	unsigned char enable_focus;
+	unsigned char enable_sharpness;
+	unsigned char device_address;
+	unsigned char camera_id;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZEPHYR_INCLUDE_DRIVERS_CAMERA_ARDUCAM_MEGA_H_ */
diff --git a/samples/drivers/video/arducam_mega_full-featured/CMakeLists.txt b/samples/drivers/video/arducam_mega_full-featured/CMakeLists.txt
new file mode 100644
index 00000000000..4c6483d678e
--- /dev/null
+++ b/samples/drivers/video/arducam_mega_full-featured/CMakeLists.txt
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.20.0)
+find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
+project(arducam_mega_full-featured)
+
+FILE(GLOB app_sources src/*.c)
+target_sources(app PRIVATE ${app_sources})
diff --git a/samples/drivers/video/arducam_mega_full-featured/README.rst b/samples/drivers/video/arducam_mega_full-featured/README.rst
new file mode 100644
index 00000000000..4f09398b0c2
--- /dev/null
+++ b/samples/drivers/video/arducam_mega_full-featured/README.rst
@@ -0,0 +1,94 @@
+.. zephyr:code-sample:: video-arducam_mega_full-featured
+   :name: Arducam mega camera full-featured sample
+
+   Capture the image frame and send to the host over
+   the serial port.
+
+Description
+***********
+
+This sample's function is to capture frames from Arducam mega camera and
+send them to the host over the UART , Users can get arducam mega full
+function's experience through the host.
+
+
+Requirements
+************
+
+This sample requires a Arducam mega camera and USB-UART module.
+
+- :ref:`rpi_pico`
+- `Arducam mega camera module`_
+
+Wiring
+******
+
+On :ref:`rpi_pico`, The Arducam mega camera module should be connected SPI0.
+The PC should be connected to UART0 using a USB to UART cable.
+
+   .. note:: Be careful during connection!
+
+    Use separate wires to connect SPI pins with pins on the rpi_pico board.
+    Wiring connection is described in the table below.
+
+    +-----------------+----------------+
+    | Arducam mega    | rpi_pico board |
+    | camera connector| SPI connector  |
+    +=================+================+
+    |      VCC        |      VCC       |
+    +-----------------+----------------+
+    |      GND        |      GND       |
+    +-----------------+----------------+
+    |      SCK        |      P18       |
+    +-----------------+----------------+
+    |      MISO       |      P16       |
+    +-----------------+----------------+
+    |      MOSI       |      P19       |
+    +-----------------+----------------+
+    |      CS         |      P17       |
+    +-----------------+----------------+
+
+    For USB to UART cable, connect the rpi_pico board as below:
+
+    +-------------+----------------+
+    | USB to UART | rpi_pico board |
+    | cable       | UART connector |
+    +=============+================+
+    |     RX      |       P0       |
+    +-------------+----------------+
+    |     TX      |       P1       |
+    +-------------+----------------+
+    |     GND     |       GND      |
+    +-------------+----------------+
+
+Building and Running
+********************
+
+For :ref:`rpi_pico`, build this sample application with the following commands:
+
+.. zephyr-app-commands::
+   :zephyr-app: samples/drivers/video/arducam_mega_full-featured
+   :board: pico
+   :goals: build
+   :compact:
+
+Using UF2
+---------
+
+You can flash the Raspberry Pi Pico with a UF2 file. By default, building
+an app for this board will generate a `build/zephyr/zephyr.uf2` file.
+If the Pico is powered on with the `BOOTSEL` button pressed, it will appear
+on the host as a mass storage device. The UF2 file should be drag-and-dropped
+to the device, which will flash the Pico.
+
+Sample Usge
+=============
+
+You can refer to the `Arducam mega GUI Guide`_ website to install and use
+the host to enjoy all the functions of the Arducam mega camera.
+
+References
+**********
+
+.. _Arducam mega camera module: https://www.arducam.com/camera-for-any-microcontroller/
+.. _Arducam mega GUI Guide: https://www.arducam.com/docs/arducam-mega/arducam-mega-getting-started/packs/GuiTool.html
diff --git a/samples/drivers/video/arducam_mega_full-featured/boards/rpi_pico.overlay b/samples/drivers/video/arducam_mega_full-featured/boards/rpi_pico.overlay
new file mode 100644
index 00000000000..6731015a307
--- /dev/null
+++ b/samples/drivers/video/arducam_mega_full-featured/boards/rpi_pico.overlay
@@ -0,0 +1,22 @@
+/**
+ * Copyright (c) 2023 Arducam Technology Co., Ltd. <www.arducam.com>
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ */
+
+&uart0{
+	current-speed = <115200>;
+};
+
+&spi0 {
+	clock-frequency = <4000000>;
+	cs-gpios = <&gpio0 17 GPIO_ACTIVE_LOW>;
+	pinctrl-names = "default";
+	arducam_mega0:arducam-mega0@0 {
+		compatible = "arducam,mega";
+		reg = <0>;
+		spi-max-frequency = <4000000>;
+		status = "okay";
+	};
+};
diff --git a/samples/drivers/video/arducam_mega_full-featured/prj.conf b/samples/drivers/video/arducam_mega_full-featured/prj.conf
new file mode 100644
index 00000000000..8a170d7da69
--- /dev/null
+++ b/samples/drivers/video/arducam_mega_full-featured/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_PRINTK=y
+CONFIG_LOG=y
+CONFIG_SERIAL=y
+
+CONFIG_SPI=y
+CONFIG_VIDEO=y
+CONFIG_VIDEO_INIT_PRIORITY=72
+CONFIG_VIDEO_BUFFER_POOL_SZ_MAX=2048
+CONFIG_VIDEO_BUFFER_POOL_NUM_MAX=3
diff --git a/samples/drivers/video/arducam_mega_full-featured/sample.yaml b/samples/drivers/video/arducam_mega_full-featured/sample.yaml
new file mode 100644
index 00000000000..3f3371947f6
--- /dev/null
+++ b/samples/drivers/video/arducam_mega_full-featured/sample.yaml
@@ -0,0 +1,10 @@
+sample:
+  name: arducam mega camera full-featured test
+tests:
+  sample.video.arducam_mega_full-featured:
+    build_only: true
+    tags: video
+    platform_allow:
+      - rpi_pico
+    integration_platforms:
+      - rpi_pico
diff --git a/samples/drivers/video/arducam_mega_full-featured/src/main.c b/samples/drivers/video/arducam_mega_full-featured/src/main.c
new file mode 100644
index 00000000000..980a38ef5df
--- /dev/null
+++ b/samples/drivers/video/arducam_mega_full-featured/src/main.c
@@ -0,0 +1,385 @@
+/**
+ * Copyright (c) 2023 Arducam Technology Co., Ltd. <www.arducam.com>
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/device.h>
+#include <zephyr/kernel.h>
+
+#include <zephyr/drivers/video.h>
+#include <zephyr/drivers/video/arducam_mega.h>
+
+#include <zephyr/drivers/uart.h>
+
+#define LOG_LEVEL CONFIG_LOG_DEFAULT_LEVEL
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(main);
+
+#define RESET_CAMERA             0XFF
+#define SET_PICTURE_RESOLUTION   0X01
+#define SET_VIDEO_RESOLUTION     0X02
+#define SET_BRIGHTNESS           0X03
+#define SET_CONTRAST             0X04
+#define SET_SATURATION           0X05
+#define SET_EV                   0X06
+#define SET_WHITEBALANCE         0X07
+#define SET_SPECIAL_EFFECTS      0X08
+#define SET_FOCUS_ENABLE         0X09
+#define SET_EXPOSURE_GAIN_ENABLE 0X0A
+#define SET_WHITE_BALANCE_ENABLE 0X0C
+#define SET_MANUAL_GAIN          0X0D
+#define SET_MANUAL_EXPOSURE      0X0E
+#define GET_CAMERA_INFO          0X0F
+#define TAKE_PICTURE             0X10
+#define SET_SHARPNESS            0X11
+#define DEBUG_WRITE_REGISTER     0X12
+#define STOP_STREAM              0X21
+#define GET_FRM_VER_INFO         0X30
+#define GET_SDK_VER_INFO         0X40
+#define SET_IMAGE_QUALITY        0X50
+#define SET_LOWPOWER_MODE        0X60
+
+#define MSG_SIZE 12
+/* queue to store up to 10 messages (aligned to 4-byte boundary) */
+K_MSGQ_DEFINE(uart_msgq, MSG_SIZE, 10, 4);
+
+const struct device *console;
+const struct device *video;
+struct video_buffer *vbuf;
+
+volatile uint8_t preview_on;
+volatile uint8_t capture_flag;
+
+void serial_cb(const struct device *dev, void *user_data);
+
+const uint32_t pixel_format_table[] = {
+	VIDEO_PIX_FMT_JPEG,
+	VIDEO_PIX_FMT_RGB565,
+	VIDEO_PIX_FMT_YUYV,
+};
+
+const uint16_t resolution_table[][2] = {
+	{160, 120},  {320, 240},   {640, 480},   {800, 600},   {1280, 720},
+	{1280, 960}, {1600, 1200}, {1920, 1080}, {2048, 1536}, {2592, 1944},
+	{96, 96},    {128, 128},   {320, 320},
+};
+
+const uint8_t resolution_num = sizeof(resolution_table) / 4;
+
+static uint8_t current_resolution;
+static uint8_t take_picture_fmt = 0x1a;
+
+int set_mega_resolution(uint8_t sfmt)
+{
+	uint8_t resolution = sfmt & 0x0f;
+	uint8_t pixelformat = (sfmt & 0x70) >> 4;
+
+	if (resolution > resolution_num || pixelformat > 3) {
+		return -1;
+	}
+	struct video_format fmt = {.width = resolution_table[resolution][0],
+				   .height = resolution_table[resolution][1],
+				   .pixelformat = pixel_format_table[pixelformat - 1]};
+	current_resolution = resolution;
+	return video_set_format(video, VIDEO_EP_OUT, &fmt);
+}
+
+void uart_buffer_send(const struct device *dev, uint8_t *buffer, uint32_t length)
+{
+	for (uint32_t i = 0; i < length; i++) {
+		uart_poll_out(dev, buffer[i]);
+	}
+}
+
+static uint8_t head_and_tail[] = {0xff, 0xaa, 0x00, 0xff, 0xbb};
+
+void uart_packet_send(uint8_t type, uint8_t *buffer, uint32_t length)
+{
+	head_and_tail[2] = type;
+	uart_buffer_send(console, &head_and_tail[0], 3);
+	uart_buffer_send(console, (uint8_t *)&length, 4);
+	uart_buffer_send(console, buffer, length);
+	uart_buffer_send(console, &head_and_tail[3], 2);
+}
+
+int take_picture(void)
+{
+	int err;
+	enum video_frame_fragmented_status f_status;
+
+	err = video_dequeue(video, VIDEO_EP_OUT, &vbuf, K_FOREVER);
+	if (err) {
+		LOG_ERR("Unable to dequeue video buf");
+		return -1;
+	}
+
+	f_status = vbuf->flags;
+
+	head_and_tail[2] = 0x01;
+	uart_buffer_send(console, &head_and_tail[0], 3);
+	uart_buffer_send(console, (uint8_t *)&vbuf->bytesframe, 4);
+	uart_poll_out(console, ((current_resolution & 0x0f) << 4) | 0x01);
+
+	uart_buffer_send(console, vbuf->buffer, vbuf->bytesused);
+
+	video_enqueue(video, VIDEO_EP_OUT, vbuf);
+	while (f_status == VIDEO_BUF_FRAG) {
+		video_dequeue(video, VIDEO_EP_OUT, &vbuf, K_FOREVER);
+		f_status = vbuf->flags;
+		uart_buffer_send(console, vbuf->buffer, vbuf->bytesused);
+		video_enqueue(video, VIDEO_EP_OUT, vbuf);
+	}
+	uart_buffer_send(console, &head_and_tail[3], 2);
+
+	return 0;
+}
+
+void video_preview(void)
+{
+	int err;
+	enum video_frame_fragmented_status f_status;
+
+	if (!preview_on) {
+		return;
+	}
+
+	err = video_dequeue(video, VIDEO_EP_OUT, &vbuf, K_FOREVER);
+	if (err) {
+		LOG_ERR("Unable to dequeue video buf");
+		return;
+	}
+
+	f_status = vbuf->flags;
+
+	if (capture_flag == 1) {
+		capture_flag = 0;
+		head_and_tail[2] = 0x01;
+		uart_buffer_send(console, &head_and_tail[0], 3);
+		uart_buffer_send(console, (uint8_t *)&vbuf->bytesframe, 4);
+		uart_poll_out(console, ((current_resolution & 0x0f) << 4) | 0x01);
+	}
+
+	uart_buffer_send(console, vbuf->buffer, vbuf->bytesused);
+
+	if (f_status == VIDEO_BUF_EOF) {
+		uart_buffer_send(console, &head_and_tail[3], 2);
+		capture_flag = 1;
+	}
+
+	err = video_enqueue(video, VIDEO_EP_OUT, vbuf);
+	if (err) {
+		LOG_ERR("Unable to requeue video buf");
+		return;
+	}
+}
+
+int report_mega_info(void)
+{
+	char str_buf[400];
+	uint32_t str_len;
+	char *mega_type;
+	struct arducam_mega_info mega_info;
+
+	video_get_ctrl(video, VIDEO_CID_ARDUCAM_INFO, &mega_info);
+
+	switch (mega_info.camera_id) {
+	case ARDUCAM_SENSOR_3MP_1:
+	case ARDUCAM_SENSOR_3MP_2:
+		mega_type = "3MP";
+		break;
+	case ARDUCAM_SENSOR_5MP_1:
+		mega_type = "5MP";
+		break;
+	case ARDUCAM_SENSOR_5MP_2:
+		mega_type = "5MP_2";
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	sprintf(str_buf,
+		"ReportCameraInfo\r\nCamera Type:%s\r\n"
+		"Camera Support Resolution:%d\r\nCamera Support "
+		"special effects:%d\r\nCamera Support Focus:%d\r\n"
+		"Camera Exposure Value Max:%ld\r\nCamera Exposure Value "
+		"Min:%d\r\nCamera Gain Value Max:%d\r\nCamera Gain Value "
+		"Min:%d\r\nCamera Support Sharpness:%d\r\n",
+		mega_type, mega_info.support_resolution, mega_info.support_special_effects,
+		mega_info.enable_focus, mega_info.exposure_value_max, mega_info.exposure_value_min,
+		mega_info.gain_value_max, mega_info.gain_value_min, mega_info.enable_sharpness);
+	str_len = strlen(str_buf);
+	uart_packet_send(0x02, str_buf, str_len);
+	return 0;
+}
+
+uint8_t recv_process(uint8_t *buff)
+{
+	switch (buff[0]) {
+	case SET_PICTURE_RESOLUTION:
+		if (set_mega_resolution(buff[1]) == 0) {
+			take_picture_fmt = buff[1];
+		}
+		break;
+	case SET_VIDEO_RESOLUTION:
+		if (preview_on == 0) {
+			set_mega_resolution(buff[1] | 0x10);
+			video_stream_start(video);
+			capture_flag = 1;
+		}
+		preview_on = 1;
+		break;
+	case SET_BRIGHTNESS:
+		video_set_ctrl(video, VIDEO_CID_CAMERA_BRIGHTNESS, &buff[1]);
+		break;
+	case SET_CONTRAST:
+		video_set_ctrl(video, VIDEO_CID_CAMERA_CONTRAST, &buff[1]);
+		break;
+	case SET_SATURATION:
+		video_set_ctrl(video, VIDEO_CID_CAMERA_SATURATION, &buff[1]);
+		break;
+	case SET_EV:
+		video_set_ctrl(video, VIDEO_CID_ARDUCAM_EV, &buff[1]);
+		break;
+	case SET_WHITEBALANCE:
+		video_set_ctrl(video, VIDEO_CID_CAMERA_WHITE_BAL, &buff[1]);
+		break;
+	case SET_SPECIAL_EFFECTS:
+		video_set_ctrl(video, VIDEO_CID_ARDUCAM_COLOR_FX, &buff[1]);
+		break;
+	case SET_EXPOSURE_GAIN_ENABLE:
+		video_set_ctrl(video, VIDEO_CID_CAMERA_EXPOSURE_AUTO, &buff[1]);
+		video_set_ctrl(video, VIDEO_CID_CAMERA_GAIN_AUTO, &buff[1]);
+	case SET_WHITE_BALANCE_ENABLE:
+		video_set_ctrl(video, VIDEO_CID_CAMERA_WHITE_BAL_AUTO, &buff[1]);
+		break;
+	case SET_SHARPNESS:
+		video_set_ctrl(video, VIDEO_CID_ARDUCAM_SHARPNESS, &buff[1]);
+		break;
+	case SET_MANUAL_GAIN:
+		uint16_t gain_value = (buff[1] << 8) | buff[2];
+
+		video_set_ctrl(video, VIDEO_CID_CAMERA_GAIN, &gain_value);
+		break;
+	case SET_MANUAL_EXPOSURE:
+		uint32_t exposure_value = (buff[1] << 16) | (buff[2] << 8) | buff[3];
+
+		video_set_ctrl(video, VIDEO_CID_CAMERA_EXPOSURE, &exposure_value);
+		break;
+	case GET_CAMERA_INFO:
+		report_mega_info();
+		break;
+	case TAKE_PICTURE:
+		video_stream_start(video);
+		take_picture();
+		video_stream_stop(video);
+		break;
+	case STOP_STREAM:
+		if (preview_on) {
+			uart_buffer_send(console, &head_and_tail[3], 2);
+			video_stream_stop(video);
+			set_mega_resolution(take_picture_fmt);
+		}
+		preview_on = 0;
+		break;
+	case RESET_CAMERA:
+		video_set_ctrl(video, VIDEO_CID_ARDUCAM_RESET, NULL);
+		break;
+	case SET_IMAGE_QUALITY:
+		video_set_ctrl(video, VIDEO_CID_JPEG_COMPRESSION_QUALITY, &buff[1]);
+		break;
+	case SET_LOWPOWER_MODE:
+		video_set_ctrl(video, VIDEO_CID_ARDUCAM_LOWPOWER, &buff[1]);
+		break;
+	default:
+		break;
+	}
+
+	return buff[0];
+}
+
+uint8_t uart_available(uint8_t *p)
+{
+	return k_msgq_get(&uart_msgq, p, K_NO_WAIT);
+}
+
+int main(void)
+{
+	uint8_t recv_buffer[12] = {0};
+	struct video_buffer *buffers[3];
+	int i = 0;
+
+	console = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
+	if (!device_is_ready(console)) {
+		LOG_ERR("%s: device not ready.", console->name);
+		return -1;
+	}
+	uart_irq_callback_user_data_set(console, serial_cb, NULL);
+	uart_irq_rx_enable(console);
+
+	video = DEVICE_DT_GET(DT_NODELABEL(arducam_mega0));
+
+	if (!device_is_ready(video)) {
+		LOG_ERR("Video device %s not ready.", video->name);
+		return -1;
+	}
+
+	/* Alloc video buffers and enqueue for capture */
+	for (i = 0; i < ARRAY_SIZE(buffers); i++) {
+		buffers[i] = video_buffer_alloc(1024);
+		if (buffers[i] == NULL) {
+			LOG_ERR("Unable to alloc video buffer");
+			return -1;
+		}
+		video_enqueue(video, VIDEO_EP_OUT, buffers[i]);
+	}
+
+	LOG_INF("Mega star");
+
+	printk("- Device name: %s\n", video->name);
+
+	while (1) {
+		if (!uart_available(recv_buffer)) {
+			recv_process(recv_buffer);
+		}
+		video_preview();
+		k_msleep(1);
+	}
+	return 0;
+}
+
+/* receive buffer used in UART ISR callback */
+static char rx_buf[MSG_SIZE];
+static int rx_buf_pos;
+
+/*
+ * Read characters from UART until line end is detected. Afterwards push the
+ * data to the message queue.
+ */
+void serial_cb(const struct device *dev, void *user_data)
+{
+	uint8_t c;
+
+	if (!uart_irq_update(dev)) {
+		return;
+	}
+
+	if (!uart_irq_rx_ready(dev)) {
+		return;
+	}
+
+	/* read until FIFO empty */
+	while (uart_fifo_read(dev, &c, 1) == 1) {
+		if (c == 0xAA && rx_buf_pos > 0) {
+			k_msgq_put(&uart_msgq, &rx_buf, K_NO_WAIT);
+			rx_buf_pos = 0;
+		} else if (c == 0x55) {
+			rx_buf_pos = 0;
+		} else {
+			rx_buf[rx_buf_pos] = c;
+			if (++rx_buf_pos >= MSG_SIZE) {
+				rx_buf_pos = 0;
+			}
+		}
+	}
+}
